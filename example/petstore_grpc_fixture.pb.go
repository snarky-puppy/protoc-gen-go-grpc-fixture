// Code generated by protoc-gen-go-grpc-fixture. DO NOT EDIT.

package petstore

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path"

	grpc "google.golang.org/grpc"
	. "google.golang.org/protobuf/types/known/emptypb"
)

var _ = Empty{}

type FixturePetStoreClient struct {
	baseDir string
}

func NewFixturePetStoreClient(baseDir string) *FixturePetStoreClient {
	return &FixturePetStoreClient{
		baseDir: baseDir,
	}
}

func (m *FixturePetStoreClient) GetAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Pets, error) {
	f := path.Join(m.baseDir, "GetAll.json")
	rv := &Pets{}
	// if file f does not exist, create it with and empty return object.
	if _, err := os.Stat(f); os.IsNotExist(err) {
		fp, err := os.Create(f)
		if err != nil {
			return nil, fmt.Errorf("failed to create %s: %w", f, err)
		}
		defer fp.Close()
		enc := json.NewEncoder(fp)
		enc.SetIndent("", "  ")
		if err := enc.Encode(rv); err != nil {
			return nil, fmt.Errorf("failed to encode %s: %w", f, err)
		}
		return rv, nil
	}
	// if file f exists, read it and return its contents.
	fp, err := os.Open(f)
	if err != nil {
		return nil, fmt.Errorf("failed to open %s: %w", f, err)
	}
	err = json.NewDecoder(fp).Decode(rv)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s: %w", f, err)
	}
	return rv, nil
}

func (m *FixturePetStoreClient) GetPet(ctx context.Context, in *Pet, opts ...grpc.CallOption) (*Pet, error) {
	f := path.Join(m.baseDir, "GetPet.json")
	rv := &Pet{}
	// if file f does not exist, create it with and empty return object.
	if _, err := os.Stat(f); os.IsNotExist(err) {
		fp, err := os.Create(f)
		if err != nil {
			return nil, fmt.Errorf("failed to create %s: %w", f, err)
		}
		defer fp.Close()
		enc := json.NewEncoder(fp)
		enc.SetIndent("", "  ")
		if err := enc.Encode(rv); err != nil {
			return nil, fmt.Errorf("failed to encode %s: %w", f, err)
		}
		return rv, nil
	}
	// if file f exists, read it and return its contents.
	fp, err := os.Open(f)
	if err != nil {
		return nil, fmt.Errorf("failed to open %s: %w", f, err)
	}
	err = json.NewDecoder(fp).Decode(rv)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s: %w", f, err)
	}
	return rv, nil
}

func (m *FixturePetStoreClient) CreatePet(ctx context.Context, in *Pet, opts ...grpc.CallOption) (*Pet, error) {
	f := path.Join(m.baseDir, "CreatePet.json")
	rv := &Pet{}
	// if file f does not exist, create it with and empty return object.
	if _, err := os.Stat(f); os.IsNotExist(err) {
		fp, err := os.Create(f)
		if err != nil {
			return nil, fmt.Errorf("failed to create %s: %w", f, err)
		}
		defer fp.Close()
		enc := json.NewEncoder(fp)
		enc.SetIndent("", "  ")
		if err := enc.Encode(rv); err != nil {
			return nil, fmt.Errorf("failed to encode %s: %w", f, err)
		}
		return rv, nil
	}
	// if file f exists, read it and return its contents.
	fp, err := os.Open(f)
	if err != nil {
		return nil, fmt.Errorf("failed to open %s: %w", f, err)
	}
	err = json.NewDecoder(fp).Decode(rv)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s: %w", f, err)
	}
	return rv, nil
}

func (m *FixturePetStoreClient) UpdatePet(ctx context.Context, in *Pet, opts ...grpc.CallOption) (*Pet, error) {
	f := path.Join(m.baseDir, "UpdatePet.json")
	rv := &Pet{}
	// if file f does not exist, create it with and empty return object.
	if _, err := os.Stat(f); os.IsNotExist(err) {
		fp, err := os.Create(f)
		if err != nil {
			return nil, fmt.Errorf("failed to create %s: %w", f, err)
		}
		defer fp.Close()
		enc := json.NewEncoder(fp)
		enc.SetIndent("", "  ")
		if err := enc.Encode(rv); err != nil {
			return nil, fmt.Errorf("failed to encode %s: %w", f, err)
		}
		return rv, nil
	}
	// if file f exists, read it and return its contents.
	fp, err := os.Open(f)
	if err != nil {
		return nil, fmt.Errorf("failed to open %s: %w", f, err)
	}
	err = json.NewDecoder(fp).Decode(rv)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s: %w", f, err)
	}
	return rv, nil
}

func (m *FixturePetStoreClient) DeletePet(ctx context.Context, in *Pet, opts ...grpc.CallOption) (*Empty, error) {
	f := path.Join(m.baseDir, "DeletePet.json")
	rv := &Empty{}
	// if file f does not exist, create it with and empty return object.
	if _, err := os.Stat(f); os.IsNotExist(err) {
		fp, err := os.Create(f)
		if err != nil {
			return nil, fmt.Errorf("failed to create %s: %w", f, err)
		}
		defer fp.Close()
		enc := json.NewEncoder(fp)
		enc.SetIndent("", "  ")
		if err := enc.Encode(rv); err != nil {
			return nil, fmt.Errorf("failed to encode %s: %w", f, err)
		}
		return rv, nil
	}
	// if file f exists, read it and return its contents.
	fp, err := os.Open(f)
	if err != nil {
		return nil, fmt.Errorf("failed to open %s: %w", f, err)
	}
	err = json.NewDecoder(fp).Decode(rv)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s: %w", f, err)
	}
	return rv, nil
}
